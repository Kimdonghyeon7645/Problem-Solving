# 첫 DP 문제, 오랜만에 알고리즘 그리고 DP라 개념을 복습하고 내 실력을 반성하는 좋은 문제
"""
DP(동적 계획법)으로 푸는 문제다
예전에 어디선가 들어봤던,
```메모리제이션(한번 연산한거 저장해뒀다 재탕하는거), 상향식(바텀->업), 하향식(탑->다운)```
이것들이 바로 DP에 관련된 것이다.
그리디는 처음 생각한 최적해가 반례없이 적용되는 경우고,
DP는 반례의 가능성을 염두했을 때 최솟값이라서, 그리디와 BP(브루트포스, 무차별대입, 완전탐색) 사이 같은 느낌이다.


* 1시간 내 풀이 실패 요인 :
사실 그리디 방식으로만 생각하고, 메모이제이션을 떠올리긴 했으나 10^6 이란 수에 너무 시간초과 날 것으로 편견을 가졌다.
그리디로는 가능한 큰 수로 나누는 방법뿐이라... 예외케이스(반례)를 죽어도 없앨 수 없어서... 50분 넘겨서도 해결이 안됬다.
그리디가 아닌 메모이제이션을 쓰는 방식으로 풀어 볼 생각을 못한 것이 주 실패 요인.

@reference https://jae04099.tistory.com/entry/파이썬-백준-1463-1로-만들기
"""
n = int(input())
d = [0] * (n+1)
for i in range(2, n+1):
    d[i] = d[i-1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
print(d[n])
""" 걍 2~n까지 다 최솟값을 구해준다. 메모리제이션을 쓰기에 성능이 좋다. 2부터 최솟값을 더해서 최솟값을 재탕하여 더 최솟값을 추리는 로직이다. (상향식) """
