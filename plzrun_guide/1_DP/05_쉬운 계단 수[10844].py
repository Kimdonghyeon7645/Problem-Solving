# 다섯번째 DP, 두번째 날 내내 푼...
"""
한시간 꽉채워서 점화식을 세웠다.
제출했는데 틀렸데서 속상한 마음으로 인터넷에 답 검색하니까 로직은 같은 맥락이였다.
결과값에 % 1000000000 넣어주니 인터넷 없이 짠 코드로 성공했다.
인터넷에서 점화식은,
d[i][j] =
    (if j == 0) d[i-1][1]
    (if j == 9) d[i-1][8]
    (else) d[i-1][j-1] + d[i-1][j+1]
과 같이 했는데 나는,
(if j == 0) d[i][1] = d[i-1][0]
(if j == 9) d[i][8] = d[i-1][9]
(else) d[i][j-1] = d[i][j] ; d[i][j+1] + d[i-1][j]
와 같이 해줬다.
인터넷 점화식은 0이면 1에서만 끌고 오고, 1이면 0과 2에서 끌고 오고, 9이면 8에서만 끌고 온다면, (Y에서 한가닥에 해당하는 곳을 기준)
나는 0이면 1로만 보내 주고, 1이면 0과 2로 보내 주고, 9이면 8로만 보내 주게 구현했다. (Y에서 두가닥에 해당하는 곳을 기준)

걍 처음 생각한 것 처럼 왼쪽에서 점점 맨 오른쪽 끝이 쌓이는 형태면 인터넷 점화식 처럼 짜도 됬는데,
오른쪽에서 맨 왼쪽 끝이 쌓이는 형태로 계산해서 좀 다른 점화식이 나왔다...
(그러다 보니 인터넷 점화식과 다르게, 최종 결과값에 맨앞이 0인 개수를 빼줘야 한다 (== d[-2][1]))
"""
n = int(input())
d = [[1] * 10]
for _ in range(n-1):
    new_d = [0] * 10
    new_d[1] += d[-1][0]
    for j in range(1, 9):
        new_d[j - 1] += d[-1][j]
        new_d[j + 1] += d[-1][j]
    new_d[8] += d[-1][9]
    d.append(new_d)

print((sum(d[-1])-(d[-2][1] if len(d) > 1 else 1)) % 1000000000)


""" 두번째 생각 (맨왼쪽 + 나머지(나머지에서 맨왼쪽 고정))
- 1 [=9]
1, 2, 3, 4, 5, 6, 7, 8, 9

- 2 [=17]
1+0
0+1 2+1
1+2 3+2
2+3 4+3
3+4 5+4
4+5 6+5
5+6 7+6
6+7 8+7
7+8 9+8
8+9

- 3
1+01      
0+10 2+10 0+12 2+12
1+21 3+21 1+23 3+23 
2+32 4+32 2+34 4+34
...
5+76 8+76 6+78 8+78
7+87 9+87 7+89 9+89
8+98
"""

""" 첫번째 생각 (왼쪽 고정)
- 1 [=9]
1, 2, 3, 4, 5, 6, 7, 8, 9

- 2 [=17]
10 12
21 23
32 34
43 45
54 56
65 67
76 78
87 89
98

- 3
    101 121 123
210 212 232 234
...
765 767 787 789
876 878 898
987 989
"""