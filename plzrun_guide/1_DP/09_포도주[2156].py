# 아홈번째 DP, 인터넷 봐도 어려웠던 문제...
"""
지금까지의 방법대로 할려했는데 마땅히 개념이 안잡힌다...
일단 케이스를 수기로 입력하고 점화식을 추론하여도 1시간을 걸렸는데 점화식을 못만들었다....

인터넷 찬스를 썼는데도 이해가 안된다... 최종적으론 아래 링크를 참고했다.
@reference : https://bio-info.tistory.com/156
현재 마시는 잔이 wine[n] (n번째 잔)이면, (n>2)
1. wine[n-2] 잔을 안 마시는 경우 (-> d[n-3] + wine[n-1] + wine[n])  (n=3이면, {0번째 잔까지 최댓값} + {2번째 잔} + {3번째 잔})
2. wine[n-1] 잔을 안 마시는 경우 (-> d[n-2] + wine[n])  (n=3이면, {1번째 잔까지 최댓값} + {3번째 잔})
3. wine[n] 잔을 안 마시는 경우  (-> d[n-1])  (n=3이면, {2번째 잔까지 최댓값})
위 3가지 케이스 중 가장 큰 값이 {n번째 잔까지 최댓값}(=d[n]) 이 된다.
"""
wine = [int(input()) for _ in range(int(input()))]
# wine = [99, 98, 1, 2, 97, 96]
d = [0] + [wine[0]] + [sum(wine[:2])] + [0] * (len(wine)-2)
# print(wine, d)
for n in range(2, len(wine)):
    d[n+1] = max(d[n-2]+wine[n-1]+wine[n], d[n-1]+wine[n], d[n])
    # 여기서 d 리스트는 1부터 시작, wine 리스트는 0부터 시작하므로, d 리스트를 참조하는 인덱스에다 +1 을 해줘야 된다.
    # print(d)
print(d[-1])
"""
## 인터넷에서 본 점화식
d[n] = max( d[n-3]+wine[n-1]+wine[n] , d[n-2]+wine[n] , d[n-1] )

## case 1 : [99, 98, 1, 2, 97, 96]
(* 괄호 안의 숫자는 d[x]에서 가져온 이미 계산된(메모이제이션 된) 값들이다.)
- n=1   : 99
- n=2   : 99+98
- n=3   : 99+98
    = max( 98+1, (99)+1, (99+98) )
- n=4   : 99+98+2
    = max( (99)+1+2, (99+98)+2, (99+98+1) )
- n=5   : 99+98+97
    = max( (99+98)+2+97, (99+98)+97, (99+98+2) )
- n=6   : 99+98+97+96
    = max( (99+98)+97+96, (99+98+2)+96, (99+98+97) )

오... 성능 확실하다. 
"""